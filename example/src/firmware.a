x0	= 0

ra	= 1
t0	= 2
t1	= 3
a0	= 4

; Remex Controller Registers

REMEX0				= $0000000000100000
  remex_rx_queue_status		= 0
    remex_rx_queue_status_empty	= $0001
    remex_rx_queue_status_full	= $0002
  remex_rx_queue_data		= remex_rx_queue_status+2

GPIA0				= $0000000000200000
  gpia_input			= 0
  gpia_output			= gpia_input+2
    gpia_output_led_on		= $0001
    gpia_output_led_off		= $FFFE

; Main program: get characters, and set LED based on bit 0 of received character.

	jal	ra, ClearQueue
Main:
	jal	ra, GetChar
	andi	a0, a0, 1
	beq	x0, a0, isZ
	jal	ra, LedOn
	jal	x0, Main

isZ:	jal	ra, LedOff
	jal	x0, Main

; Empties the receive queue, so we always start at a known-good place.

ClearQueue:
	lui	t0, REMEX0

	; Receive character from the queue.

cq0:	lh	t1, remex_rx_queue_data(t0)

	; Repeat if the queue remains non-empty.

	lhu	t1, remex_rx_queue_status(t0)
	andi	t1, t1, remex_rx_queue_status_empty
	beq	x0, t1, cq0
	jal	x0, 0(ra)

; Polls for a character from Remex port 0.
; This procedure can block indefinitely if no character arrives.

GetChar:
	; Wait for a character to appear.

	lui	t0, REMEX0
gc0:	lhu	t1, remex_rx_queue_status(t0)
	andi	t1, t1, remex_rx_queue_status_empty
	bne	x0, t1, gc0

	; Read character from the FIFO.

	lh	a0, remex_rx_queue_data(t0)

	; Return character in a0.

	jalr	x0, 0(ra)

; Turns LED on or off.

LedOn:
	lui	t0, GPIA0
	lhu	t1, gpia_output(t0)
	ori	t1, t1, gpia_output_led_on
	sh	t1, gpia_output(t0)
	jalr	x0, 0(ra)

LedOff:
	lui	t0, GPIA0
	lhu	t1, gpia_output(t0)
	andi	t1, t1, gpia_output_led_off
	sh	t1, gpia_output(t0)
	jalr	x0, 0(ra)

; Flesh out the rest of the ROM image.

	adv	$100, $CC

